/*
Arduino sketch for DDS-60 controller
Described at http://www.theladderline.com/dds-60

Author: Ross Keatinge
Email: tetranz (at) gmail.com
Amateur radio callsign: KT1F
Date: March 6th 2010

Creative Commons Attribution-Noncommercial-Share Alike 3.0 United States License
http://creativecommons.org/licenses/by-nc-sa/3.0/us/

Revision 1.1 - March 11th 2010
Now using our own LCD driver code instead of Arduino LiquidCrystal library

Revision 1.2 - March 12th 2010
Now using our own code to write to DDS instead of ShiftOut

Revision 1.3 - March 14th 2010
We now have QRSS mode!

Revision 1.31 - May 3rd 2010 - Bug fix
Reset frequency (i.e, key up) when switching away from QRSS.
QRSS dot time changed to six seconds.

Revision 1.4 - October 30th
Transceiver mode for direct conversion transceiver.
See http://www.theladderline.com/qrp-40-meter-cw-transceiver
*/

#include <EEPROM.h>

// define our event codes
const byte BUTTON_PUSH_EVENT = 1;     // push a button
const byte BUTTON_HOLD_EVENT = 2;     // hold a button down for 5 seconds
const byte ENCODER_TURN_EVENT = 3;    // the encoder was turned

// these are the event code and parameter generated by our I/O code
byte _event = 0;
int _eventParam;

int _ms;  // our main timing variable instead of using millis() directly. See comments in main loop.

volatile byte _encoderCount  = 0;  // used by interupt code to communicate encoder rotation to main loop
// encoder speed setting. 1 = maximum speed, 2 = half speed etc. This should only be set to a power of 2.
byte _encoderSpeed = 1;

const byte MEMORY_CHANNEL_MAX = 99;  // lets have 99 memory channels

// addresses used in EEPROM
const int EE_FREQUENCY = 0;    // last frequency
const int EE_CALIBRATION = 4;  // calibration offset
const int EE_MODE = 6;         // mode
const int EE_MEMORY_CHANNELS = 1024 - (MEMORY_CHANNEL_MAX * 4);  // put the memory channels at the top of the EEPROM

// frequency range
const long FREQ_MIN = 1000000;    // 1 MHz
const long FREQ_MAX = 60000000;   // 60 MHz

// the limits of the LSB of the clock value. 
// 180,000,000 is ABA9500 hex. We make use of the convenient fact that + or - 100 ppm (18 KHz) only changes the 2 least significant bytes.
// This means that we can do a simple and quick OR with CLOCK_BASE to get the final clock to calculate the delta to send to the DDS
const unsigned long CLOCK_LSB_MIN = 0x4EB0;
const unsigned long CLOCK_LSB_MAX = 0xDB50;

// 64 bit 2 to the power of 32.
// note that this is a 64 bit integer using the int64_t type.
const int64_t TWO_E32 = 0x100000000LL;
const long CLOCK_BASE = 180000000 & 0xFFFF0000;  // Upper bits of 180 MHz. ORed with _clockLSB when programming DDS

// modes
const byte NORMAL_MODE = 0;
const byte TRANS_MODE = 1;
const byte MEMORY_MODE = 2;
const byte MEMORY_CONFIRM_MODE = 3;
const byte QRSS_MODE = 4;
const byte CALIBRATE_MODE = 5;
const byte SILENT_MODE = 6;

byte _mode; // the current mode
unsigned int _clockLSB;  // calibration value. 0x9500 for clock = exactly 180 MHz

unsigned int _saveClockLSB;  // save _clockLSB in case we don't commit to calibration adjustment

long _frequency;    // current frequency in Hz
long _frequencyStep = 100;  // selected frequency step in Hz
long _normalFrequencyStep;
long _ritFrequencyStep = 10;  // default step for RIT

boolean _frequencyHasChanged = false;  // set of the frequency has changed. Used for saving frequency to EEPROM
boolean _modeHasChanged = false;

byte _memoryChannel = 1;  // selected memory channel
long _memoryFrequency;    // frequency of selected memory channel

byte _buttonPorts[3];  // holds the port numbers of the push buttons.

const byte SIDETONE_PORT = 11;    // audio sidetone out
const byte CW_PORT = 12;          // CW keying in
const byte TR_PORT = 13;          // Transmit / Receive switching out

// CW audio frequency in Hz.
// This controls both the DDS frequency shift between TX and RX and the sidetone audio.
const int CW_FREQ = 800;

// transmit timeout in ms. This is the key up time required before switching back to receive
const int TX_TIMEOUT = 750;

int _ritOffset = 0;
boolean _ritOn = false;
boolean _transmit = false;
boolean _key_down = false;

void setup()
{
  LCDInitialize();    // initialize the LCD for 4 bit data mode
  
  // Set push button port numbers. The array index starts at zero but I find it easier to think of the buttons as 1, 2 and 3.
  // We use the Arduino digital port functions for the (slow) buttons so it's easy to add more buttons to the 3 spare ports
  // but, to get good performance, we write directly to the port registers for the DDS, LCD and encoder.
  _buttonPorts[0] = 8;   // button 1
  _buttonPorts[1] = 9;   // button 2
  _buttonPorts[2] = 10;  // button 3

// initialize the button ports
  for (int i = 0; i < sizeof(_buttonPorts); i++)
  {
// These two lines should probably be reversed
// See the March 2013 update: http://www.theladderline.com/node/18
    digitalWrite(_buttonPorts[i], HIGH);  // enable pull-up resistor
    pinMode(_buttonPorts[i], INPUT);      // set port as input
  }

SetTxRx(false);
pinMode(TR_PORT, OUTPUT); // these are outputs
pinMode(SIDETONE_PORT, OUTPUT);

// CW port is an input
digitalWrite(CW_PORT, HIGH);  // turn on the pull-up resistor for the open collector interface on the transeiver.
pinMode(CW_PORT, INPUT);

// setup ports with |= and &= to avoid disturbing serial / USB ports 0 and 1
  DDRD &= B11110011;   // encoder ports as inputs
  DDRD |= B01110000;   // set DDS ports as outputs
  PORTD |= B00001100;  // set encoder inputs to use pull-up resistors
  PORTD &= B10001111;  // set DDS ports low
  
  _clockLSB = ReadIntFromEEPROM(EE_CALIBRATION);  // read calibration value from EEPROM

  // if it is outside + or - 9999 Hz then set it from 0 Hz, i.e., clock assumed to be exactly  180 MHz
  if (_clockLSB < CLOCK_LSB_MIN || _clockLSB > CLOCK_LSB_MAX)
  {
    _clockLSB = 0x9500;
    SaveToEEPROM(_clockLSB, EE_CALIBRATION);
  }

  WriteToDDS(0);  // write 0 to the DDS. This might not be necessary but it keeps it off until we set it to a known frequency

  // enable interupts and attach our interupt routines. Set to trigger on every transition of the inputs
  attachInterrupt(0, Interrupt0, CHANGE);
  attachInterrupt(1, Interrupt1, CHANGE);

  delay(250);    // delay 1/4 second. This seems to help ensure a clean power-up
  ReadEncoder();  // throw away any initial interupts on power up

  _frequency = ReadLongFromEEPROM(EE_FREQUENCY);    // get freqency from EEPROM
  
// set it to some favorite frequency if it is out of range. This should really only happen on the first power-up
  if (_frequency < FREQ_MIN || _frequency > FREQ_MAX)
  {
     _frequency = 3560000;
  }

  SetDDSFrequency();  // set the DDS to the selected frequency

  _event = 0;  // no events are happening yet

  _mode = EEPROM.read(EE_MODE);  // read the last mode setting from EEPROM

// saving the mode is mostly for the benefit of QRSS mode so we restart after a power failure
// there doesn't seem much sense to start in CALIBRATE or MEMORY mode
// so we start in TRANS, QRSS or NORMAL
  if (_mode == TRANS_MODE || _mode == QRSS_MODE)
  {
    SetMode(_mode, true);
  }
  else
  {
    SetMode(NORMAL_MODE, true);
  }
}

// ----------------------------------------------------
//  Main loop
// ---------------------------------------------------- */

void loop()
{
    // We need to keep track of elapsed time for the various delays. millis() returns a 32 bit long.
    // If we only use the lower 16 bits then it will cycle around (overflow) every 65 seconds or so. That's plenty for us.
    // Since _ms is an int, our other time variables only need to be ints rather than longs
    // With the usual 2s complement arithmetic, "elapsed" calculations work fine without us needing to do anything special for overflow.
    _ms = millis() & 0xFFFF;
    
    ReadButtons();  // read the buttons
    
    if (!_event)  // read the encoder if no button was pushed
    {
      ReadEncoder();
    }
    
    if (_event && _mode != QRSS_MODE)  // was there an event?
    {
      switch(_mode)    // yes, so lets direct it to the appropriate mode routine
      {
        case NORMAL_MODE:
          NormalMode();
          break;

        case TRANS_MODE:
          TransceiverMode();
          break;
          
        case MEMORY_MODE:
          MemoryMode();
          break;

        case MEMORY_CONFIRM_MODE:
          MemoryConfirmMode();
          break;

        case CALIBRATE_MODE:
          CalibrateMode();
          break;

        case SILENT_MODE:
          SilentMode();
          break;
      }  
       _event = 0;    // The event has been processed
    }

    if (_mode == QRSS_MODE)
    {
      QRSSMode(false);
    }

// Save the frequency and mode in EEPROM if these have changed.
// Because of the save delay to protect the EEPROM from excessive writes, this is called every time whether or not an event happened.
    SaveStateToEEPROM();
    
    if (_mode == TRANS_MODE)
    {
      DoCW();  // do the CW logic
    }
}

void DoCW()
{
  static int lastKeydownMS;
  
  boolean was_key_down = _key_down;    // remember the key state
  _key_down = !digitalRead(CW_PORT);   // read the new key state
  
  if (_key_down)
  {
    if (!_transmit)  // if key is down and we are not on transmit then go to transmit 
    {
      SetTxRx(true);
    }
    
    if (!was_key_down)  // if key is down but was up before (i.e, it's just been pressed) then start sidetone
    {
      tone(SIDETONE_PORT, CW_FREQ);
    }
    
    lastKeydownMS = _ms;  // remember the last time the key was down
  }
  else
  {
    // key is up 
    if (was_key_down)  // if key up but was down before (i.e, it's just been released) then end sidetone
    {
      noTone(SIDETONE_PORT);
    }
    
    if (_transmit)
    {
// if we're on transmit but the key has been up for the timeout period then go to receive.
      int elapsed = _ms - lastKeydownMS;
      if (elapsed > TX_TIMEOUT)
      {
        SetTxRx(false);
      }
    }
  }
}

//
// NORMAL mode. This is the normal "turn the dial and the frequency changes" mode
//
void NormalMode()
{
  switch(_event)
  {
    case ENCODER_TURN_EVENT:  // encoder was turned
      _frequency += ((long) _eventParam) * _frequencyStep;    // adjust the frequency by the amount the encoder moved
      _frequency = RestrictFrequency(_frequency);             // restrict the frequency to the allowable range
      SetDDSFrequency();                                      // set the DDS to the new frequency
      PrintFrequency(_frequency);                             // print the new frequency
      _frequencyHasChanged = true;                               // remember that te frequency has changed so we can save it to EEPROM later
      break;
       
    case BUTTON_PUSH_EVENT:  // a button was pressed
      switch(_eventParam)
      {
        case 1:
          SetMode(TRANS_MODE);  // move to QRSS mode
          break;

        case 2:
          SetMode(SILENT_MODE);  // turn the output off.
          break;
            
        case 3:
          IncrementFrequencyStep();  // change the frequency step
          PrintFrequencyStep();      // print the new frequency step
          break;
      }
      break;
  }
}

void TransceiverMode()
{
  switch(_event)
  {
    case ENCODER_TURN_EVENT:  // encoder was turned
      if (!_transmit)    // ignored on transmit
      {
        if (_ritOn)
        {
          // RIT is on so move and print RIT offset
          _ritOffset += _eventParam * _frequencyStep;
          // restrict RIT to + or - 9.999 KHz
          if (_ritOffset > 9999)
          {
            _ritOffset = 9999;
          }
          else if (_ritOffset < -9999)
          {
            _ritOffset = -9999;
          }
          PrintOffset(_ritOffset);
        }
        else
        {
          _frequency += ((long) _eventParam) * _frequencyStep;    // adjust the frequency by the amount the encoder moved
          _frequency = RestrictFrequency(_frequency);             // restrict the frequency to the allowable range
          PrintFrequency(_frequency);                             // print the new frequency
          _frequencyHasChanged = true;                            // remember that the frequency has changed so we can save it to EEPROM later
        }
  
        SetDDSFrequency();
      }
      break;
       
    case BUTTON_PUSH_EVENT:  // a button was pressed
      switch(_eventParam)
      {
        case 1:
          SetMode(QRSS_MODE);  // move to QRSS mode
          break;

        case 2:
          SetRit(!_ritOn);    // toggle RIT
          SetDDSFrequency();
          break;

        case 3:
          IncrementFrequencyStep();  // change the frequency step
          PrintFrequencyStep();      // print the new frequency step
          break;
      }
      break;
  }
}

void SetRit(boolean onOff)
{
  _ritOffset = 0;

  if (onOff)  // setting RIT on
  {
    _normalFrequencyStep = _frequencyStep;    // save freq step for normal tuning
    _frequencyStep = _ritFrequencyStep;       // restore RIT frequency step
    PrintOffset(_ritOffset);                  // print frequency step
  }
  else
  {
    if (_mode == TRANS_MODE && _ritOn)      // logic so we can call this even if RIT was already off
    {
      _ritFrequencyStep = _frequencyStep;
    }
    
    _frequencyStep = _normalFrequencyStep;
    ClearOffsetArea();
  }

  PrintFrequencyStep();
  _ritOn = onOff;
}

void SetTxRx(boolean state)
{
// toggle the transmit / receive state
  _transmit = state;
  digitalWrite(TR_PORT, state);

  if (_transmit)
  {
    LCDPrint("TX", 14, 0);
  }
  else
  {
    LCDPrint("RX", 14, 0);
  }

  SetDDSFrequency();
}

void MemoryMode()
{
  switch(_event)
  {
    case ENCODER_TURN_EVENT:    // the encoder was turned

      _memoryChannel += _eventParam;  // move the memory channel up or down

      if (_memoryChannel < 1)        // cycle around if we go outside the range
      {
         _memoryChannel = MEMORY_CHANNEL_MAX; 
      }
      else if (_memoryChannel > MEMORY_CHANNEL_MAX)
      {
          _memoryChannel = 1;
      }

      GetMemoryChannel();    // get the frequency of the new channel and display
      break;
   
    case BUTTON_PUSH_EVENT:    // a button was pressed
      switch(_eventParam)
      {
        case 1:
          SetMode(CALIBRATE_MODE);  // move to calibrate mode
          break;
          
        case 2:
        // if the selected channel is not "empty" then set the DDS to the new frequency and return to NORMAL mode
          if (_memoryFrequency)      
          {
            _frequency = _memoryFrequency;
            SetDDSFrequency();
            _frequencyHasChanged = true;
          }
          SetMode(NORMAL_MODE);
          break;
          
        case 3:
          SetMode(MEMORY_CONFIRM_MODE);  // we have chosen to save into this channel so move to confirm mode
          break;
      }
  }
}

void MemoryConfirmMode()
{
  // the display is saving "Save ?" and waiting for a button push

  if (_event == BUTTON_PUSH_EVENT && _eventParam == 3)
  {
  // button 3 pressed so  save to that memory channel
    SaveToEEPROM(_frequency, EE_MEMORY_CHANNELS + ((_memoryChannel - 1) * 4));
    SetMode(NORMAL_MODE);
  }
  else if (_event == BUTTON_HOLD_EVENT && _eventParam == 3)
  {
  // button 3 held so erase that memory channel
    _memoryFrequency = 0;
    SaveToEEPROM(_memoryFrequency, EE_MEMORY_CHANNELS + ((_memoryChannel - 1) * 4));
    ClearLowerRight();
    PrintFrequency(_memoryFrequency);
    SetMode(MEMORY_MODE);
  }
  else
  {
  // return to normal mode without changing memory channel
    ClearLowerRight();
    SetMode(MEMORY_MODE);
  }
}

void CalibrateMode()
{
  switch(_event)
  {
    case ENCODER_TURN_EVENT:  // the encoder was turned
      _clockLSB += ((long) _eventParam) * _frequencyStep;  // move the _clockLSB calibration value up or down
      RestrictClock();    // restrict to + or - 9999
      PrintClock();       // print the new calibration value
      SetDDSFrequency();  // set the DDS frequency using the new calibration value
      break;

    case BUTTON_PUSH_EVENT:
      switch(_eventParam)
      {
        case 1:  // button 1 pressed. Return to normal mode without saving calibration value
          _clockLSB = _saveClockLSB;
          SetDDSFrequency();
          SetMode(NORMAL_MODE);
          break;
          
        case 2:  // button 2 pressed. Save new calibration value
          SaveToEEPROM(_clockLSB, EE_CALIBRATION);
          SetMode(NORMAL_MODE);
          break;

        case 3:  // button 3 pressed. Change increment. 
          IncrementFrequencyStep();
          PrintFrequencyStep();
          break;
      }
  }
}

void SilentMode()
{
   // toggle between NORMAL and SILIENT modes with button 2
  if (_event == BUTTON_PUSH_EVENT && _eventParam == 2)
  {
    SetDDSFrequency();
    SetMode(NORMAL_MODE);
  }
}

void SetMode(byte mode)
{
  SetMode(mode, false);
}

// setup for new mode
void SetMode(byte mode, boolean init)
{
  if (_ritOn)  // start new mode with RIT off
  {
    SetRit(false);
  }
  
  boolean setFreq = false;
  boolean printStep = false;
  
  _mode = mode;
  switch(mode)
  {
    case NORMAL_MODE:
      LCDClear();
      _encoderSpeed = 1;
      ReadEncoder();  // throw away any extra encoder movement
      setFreq = true;
      printStep = true;
      break;

    case TRANS_MODE:
      LCDClear();
      ReadEncoder();  // throw away any extra encoder movement
      SetTxRx(false);
      _ritOn = false;
      _ritOffset = 0;
      if (!init)
      {
        _frequency -= CW_FREQ;  // this avoids the DDS moving frequency
      }
      setFreq = true;
      printStep = true;
      break;
      
    case QRSS_MODE:
      if (!init)
      {
        _frequency += CW_FREQ;    // this avoids the DDS moving frequency
      }
      PrintFrequency(_frequency);
      ClearLowerRight();
      PrintMode("QRSS ");
      QRSSMode(true);
      printStep = true;
      break;

    case MEMORY_MODE:
      SetDDSFrequency();    // set frequency in case we were shifted for QRSS key down
      _encoderSpeed = 2;          
      PrintMode(" Mem ");
      ClearLowerRight();
      GetMemoryChannel();
      break;

    case MEMORY_CONFIRM_MODE:
      LCDPrint(" Save ?", 9, 1);
      break;
    
    case CALIBRATE_MODE:
      _saveClockLSB = _clockLSB;
      _encoderSpeed = 1;
      PrintMode("Calib");
      PrintClock();
      setFreq = true;
      printStep = true;
      break;
    
    case SILENT_MODE:
      WriteToDDS(0);
      PrintMode("Quiet");
      break;
  }

  if (setFreq)
  {
    PrintFrequency(_frequency);
    SetDDSFrequency();
  }

  if (printStep)
  {
    PrintFrequencyStep();
  }
  
  _modeHasChanged = true;
}

// retrieve and print the memory channel in _memoryChannel
void GetMemoryChannel()
{
  char str[5];
  sprintf(str, "M %2i", _memoryChannel);  // format as M nn where nn is memory channel
  LCDPrint(str, 0, 1);

  _memoryFrequency = ReadLongFromEEPROM(EE_MEMORY_CHANNELS + ((_memoryChannel - 1) * 4));
  
  // restrict frequency if out of range
  if (_memoryFrequency < FREQ_MIN || _memoryFrequency > FREQ_MAX)
  {
     _memoryFrequency = 0; 
  }
  
  PrintFrequency(_memoryFrequency); 
}

// save current frequency to EEPROM
void SaveStateToEEPROM()
{
  static int lastSaveMS;  // remember when we last did this. Note: a static variables retains its value on each call of this routine
  int elapsed = _ms - lastSaveMS;

// we only do this every 5 seconds
  if (elapsed >= 5000)
  {
    // only save if the frequency has actually changed
    if (_frequencyHasChanged)
    {
      SaveToEEPROM(_frequency, EE_FREQUENCY);
      _frequencyHasChanged = false;
    }
    
    if (_modeHasChanged)
    {
      if (EEPROM.read(EE_MODE) != _mode)
      {
        EEPROM.write(EE_MODE, _mode);
      }
      _modeHasChanged = false;
    }
    
    lastSaveMS = _ms;
  }
}

// cycle the frequency step around 100 KHz, 10 KHz, 1 KHz, 100 Hz, 10 Hz, 1 Hz
void IncrementFrequencyStep()
{
  if (_frequencyStep == 1)
  {
    _frequencyStep = 100000; 
  }
  else
  {
    _frequencyStep = _frequencyStep / 10;
  }
}

// --------------------------------------------------------
// Read buttons
// --------------------------------------------------------

void ReadButtons()
{
  // define some sub modes
  const byte WAIT_FOR_DOWN = 0;    // wait for a button press
  const byte WAIT_FOR_UP_OR_TIME = 1;  // wait for buttion to be released or for it to be pressed long enough to be considered "held".
  const byte WAIT_FOR_ALL_UP = 2;  // waiting for all buttons released

  static int lastReadMS = 0;    // remember when we last did this
  static int downTimeMS = 0;    // how long has the button been held down
  static byte state = WAIT_FOR_DOWN;  // start by waiting for a button press
  static byte activeButton;    // the button that was pushed or held last time

  int elapsed = _ms - lastReadMS;    // how long since we last did this?
  
  // only check the buttons every 100 ms (i.e, 10 times a second).
  // this is how we debounce the button contacts
  if (elapsed < 100)
  {
    return;
  }
    
  lastReadMS = _ms;

  // Is there a button currently pressed?
  // We only want to know about one button down at the time. i.e, we're not implementing any "shift" keys.
  // Note that the other side of the buttons are grounded so the port reads zero when a button is pressed.
  
  // My buttons are all on PORTB so the code could be simplified and made slightly faster by reading PORTB directly in one operation
  // but this is more generic and makes it simple to change the port assignments or add more buttons.
  
  byte buttonDown = 0;
  for (int i = 0; !buttonDown && i < sizeof(_buttonPorts); i++)
  {
    if (!digitalRead(_buttonPorts[i]))
    {
      buttonDown = i + 1;
    }
  }
  
  // at this point, buttonDown > 0 means that a button is pressed

  switch(state)
  {
    case WAIT_FOR_DOWN:
      if (buttonDown)  // a button is pressed
      {
        downTimeMS = _ms;    // start the hold counter
        state = WAIT_FOR_UP_OR_TIME;  // wait for release or timeout
        activeButton = buttonDown;    // remember which button is active for next time around the loop

        _event = BUTTON_PUSH_EVENT;    // raise button push event
        _eventParam = activeButton;    // tell other code which button was pressed
      }
      break;
    
    case WAIT_FOR_UP_OR_TIME:
      if (buttonDown != activeButton)
      {
// the button that was pressed is now up
        if (buttonDown)
        {
// we prefer all buttons to be up now. i.e, we're do cope with two buttons pressed at the same time
          state = WAIT_FOR_ALL_UP;
        }
        else
        {
          state = WAIT_FOR_DOWN;  // nothing pressed now so go back to waiting for the next button press
        }
      }
      else
      {
        // button is still pressed
        elapsed = _ms - downTimeMS;  // how long has it been pressed?
        
        if (elapsed >= 5000)      // consider it "held" if it has been pressed for 5 seconds
        {
          _event = BUTTON_HOLD_EVENT;  // raise button hold event
          _eventParam = activeButton;  // tell other code which button was held
          state = WAIT_FOR_ALL_UP;    // wait for all released
        }
      }
      break;

    case WAIT_FOR_ALL_UP:
      if (!buttonDown)
      {
        state = WAIT_FOR_DOWN;  // all released so wait for next press
      }
      break;
  }
}

// --------------------------------------------------------
// Read encoder
//
// --------------------------------------------------------

void ReadEncoder()
{
// the interupt codes moves _encoderCount up or down.

  static int prevCount;

// read the count into another variable. It's a single byte so it's safe to read without stopping interupts
  byte count = _encoderCount;
  
  int diff = count - prevCount;  // how much has it shifted

  // this handles overflow or underflow of _encoderCount
  if (diff < -100)
  {
    diff += 256;
  }
  else if (diff > 100)
  {
    diff -= 256;
  }

  if (_encoderSpeed > 1)  // reduce the speed if necessary
  {
    diff = diff / _encoderSpeed;
  }

  // if diff is > 0 then we moved clockwise
  // if diff is < 0 then we moved counterclockwise
  
  if (diff != 0)
  {
  // the encoder moved
    prevCount = count;              // remember for next time
     _event = ENCODER_TURN_EVENT;   // raise event
     _eventParam = diff;            // turn other code how far we moved and in what direction
  }
}

// ---------------------------------------------------------------------------------------------------------------
// Interupts
// we want to do as little as possible here.
// by knowing which pin caused the interupt and the state of both pins, we can figure out which direction it moved
// ---------------------------------------------------------------------------------------------------------------

void Interrupt0()
{
  // this is called whenever pin A of the encoder changes
  byte inpB = PIND & 8;
  
  if (PIND & 4)
  {
    if (inpB)
    {
      _encoderCount--;
    }
    else
    {
      _encoderCount++;
    }
  }
  else
  {
    if (inpB)
    {
      _encoderCount++;
    }
    else
    {
      _encoderCount--;
    }
  }
}

void Interrupt1()
{
  byte inpA = PIND & 4;

  if (PIND & 8)
  {
    if (inpA)
    {
      _encoderCount++;
    }
    else
    {
      _encoderCount--;
    }
  }
  else
  {
    if (inpA)
    {
      _encoderCount--;
    }
    else
    {
      _encoderCount++;
    }
  }
}

// --------------------------------------------------------
// Printing
// --------------------------------------------------------

void PrintFrequency(long frequency)
{
  if (frequency == 0)  // an "empty" memory channel returns frequency == 0
  { 
    LCDPrint("  Empty   ", 0, 0);
  }
  else
  {
    // this formats the frequency in the typical transceiver format with two decimal points separating MHz and KHz
    char str[11];
    sprintf(str, "%010lu", frequency);
    str[0] = str[2];
    str[1] = str[3];
    str[2] = '.';
    str[3] = str[4]; 
    str[4] = str[5]; 
    str[5] = str[6]; 
    str[6] = '.';
    
    if (frequency < 10000000)
    {
      str[0] = ' ';  
    }
  
    LCDPrint(str, 0, 0);
  }
}

// print the mode in the top left
void PrintMode(char str[6])
{
  LCDPrint(str, 11, 0);
}

void ClearLowerRight()
{
   LCDClearArea(9, 1, 7);
}

// prinnt the frequency step in the lower right
void PrintFrequencyStep()
{
  char str[8];
   if (_frequencyStep < 1000)
   {
     sprintf(str, "%4lu Hz", _frequencyStep);
   }
   else
   {
     sprintf(str, "%3lu KHz", _frequencyStep / 1000);
   }
   LCDPrint(str, 9, 1);
}

// print the calibration value
void PrintClock()
{
  // if _clockLSB == 0x9500 then the offset is zero
  PrintOffset(_clockLSB - 0x9500);
}

void PrintOffset(int offset)
{
  if (offset)
  {
    char str[7];
    sprintf(str, "%+6i", offset);
    LCDPrint(str, 0, 1); 
  }
  else
  {
    LCDPrint("     0", 0, 1);
  }
}

void ClearOffsetArea()
{
  LCDClearArea(0, 1, 7);
}

// Set the DDS frequency
void SetDDSFrequency()
{
  if (_mode == TRANS_MODE && !_transmit)
  {
    SetDDSFrequency(_frequency + CW_FREQ + _ritOffset);
  }
  else
  {
    SetDDSFrequency(_frequency);
  }
}

void SetDDSFrequency(long frequency)
{
  long clock = CLOCK_BASE | _clockLSB;  // get the clock frequency to use. if _clockLSB is 0x9500 then this is exactly 180 MHz
  
  // calculate and write the required delta to the DDS
  // the formula is delta = frequency * (2 to the power of 32) / clock frequency
  WriteToDDS((frequency * TWO_E32) / clock);
}

void WriteToDDS(long delta)
{
 // we shift 5 bytes, i.e, 40 bits LSB first
  PORTD &= B10111111;       // load line low
  WriteByteToDDS(delta);    // shift out first byte

// now do the other 3 bytes of the delta value
  for (int i = 0; i < 3; i++)
  {
    delta = delta >> 8;
    WriteByteToDDS(delta);
  }
  
// this follows example in AD9841 data sheet
  WriteByteToDDS(0x09);
  PORTD |= B01000000;       // load line high
}

// Serially shift 8 bits out to the DDS
// this is faster than using the Arduino ShiftOut function
void WriteByteToDDS(byte data)
{
  byte mask = 1;  // mask to pick out the bit to send
  for (int i = 0; i < 8; i++)
  {
      if (data & mask)
      {
         PORTD |= B00010000;      // sending 1 so set data bit high
         PORTD &= B11011111;      // set clock low
      }
      else
      {
         PORTD &= B11001111;     // sending 0 so set data and clock both low
      }
      
      // 1us delays are much longer than we need. The AD9851 datasheet indicates that only a few ns are necessary
      // but it seems foolish to push our luck with long wires to the display etc.
      // with 1us delays we still shift out 40 bits in about 130us which is plenty fast enough
      // and much faster than using ShiftOut which takes about 620us.

      delayMicroseconds(1);      // let data settle
      PORTD |= B00100000;        // set clock high
      delayMicroseconds(1);      // data hold delay
      
      mask = mask << 1;          // shift for next bit
  }
}

long RestrictFrequency(long frequency)
{
  if (frequency < FREQ_MIN)
  {
    frequency = FREQ_MIN;
  }
  else if (frequency > FREQ_MAX)
  {
     frequency = FREQ_MAX; 
  }
  
  return frequency;
}

void RestrictClock()
{
    if (_clockLSB < CLOCK_LSB_MIN)
    {
       _clockLSB = CLOCK_LSB_MIN; 
    }
    else if (_clockLSB > CLOCK_LSB_MAX)
    {
       _clockLSB = CLOCK_LSB_MAX; 
    }
}

// --------------------------------------------------------
// EEPROM
// --------------------------------------------------------

void SaveToEEPROM(unsigned int value, int address)
{
  // save a 2 byte int to EEPROM. The MSB is saved to the lowest address
  
  address += 1;
  
  for (int i = 0; i < 2; i++)
  {
    byte toSave = value & 0xFF;
    
    if (EEPROM.read(address) != toSave)  // only write if we really need to so we avoid excessive writes
    {
       EEPROM.write(address, toSave); 
    }
    
    value = value >> 8;
    address--;
  }
}

void SaveToEEPROM(long value, int address)
{
  // save a 4 byte long to EEPROM. The MSB is saved to the lowest address

  address += 3;
  
  for (int i = 0; i < 4; i++)
  {
    byte toSave = value & 0xFF;
    
    if (EEPROM.read(address) != toSave)  // only write if we really need to so we avoid excessive writes
    {
       EEPROM.write(address, toSave); 
    }
    
    value = value >> 8;
    address--;
  }
}

// read 2 byte int from EEPROM
unsigned int ReadIntFromEEPROM(int address)
{
  unsigned int value = EEPROM.read(address);
  value = value << 8;
  return value | EEPROM.read(address + 1);
}

// read 4 byte long from EEPROM
long ReadLongFromEEPROM(int address)
{
  long value = 0;
  for (int i = 0; i < 4; i++)
  {
    value = value | EEPROM.read(address);
    if (i < 3)
    {
      value = value << 8;
      address++;  
    }
  }
  
  return value;
}

// ----------------------
// LCD driver
// ----------------------

void LCDInitialize()
{
  DDRC = B00111111;
  PORTC = 0;

  // setup 4 bit mode following page 46 of the HD44780 datasheet
  
  delayMicroseconds(50000);    // wait 50 ms at power-up
  LCDWrite4Bits(0x03, false);
  delayMicroseconds(5000);
  
  LCDWrite4Bits(0x03, false);
  delayMicroseconds(200);
    
  LCDWrite4Bits(0x03, false); 
  delayMicroseconds(200);
  
  LCDWrite4Bits(0x02, false); 
  delayMicroseconds(5000);
  
  // we are now in 4 bit mode
  
  LCDWrite(0x28, false);  // 2 lines
  LCDWrite(0x08, false);  // display off, cursor off
  LCDClear();             // clear the display
  LCDWrite(0x06, false);  // increment cursor after writing. Don't shift display
  LCDWrite(0x0C, false);  // move cursor, not the display. Move to right
}

// print at string at specified position
void LCDPrint(char *str, byte column, byte row)
{
  LCDSetCursor(column, row);
  LCDPrint(str);
}

// print at string cursor position
void LCDPrint(char *str)
{
   while (*str)
   {
      LCDWrite(*str++, true);
   }
}

// clear an area of the display. This is probably more efficient and wastes
// less space than potentially having "   " of varying lengths throughout the code
void LCDClearArea(byte column, byte row, byte length)
{
  LCDSetCursor(column, row);
  
  for (int i = 0; i < length; i++)
  {
     LCDWrite(' ', true); 
  }
}

// clear display. Note the 2 ms delay
void LCDClear()
{
  LCDWrite(0x01, false);
  delayMicroseconds(2000);
}

// set the cursor position
void LCDSetCursor(byte column, byte row)
{
  byte bits = row ? 0xC0 : 0x80;
  LCDWrite(bits | column, false); 
}

// write a byte as 2 writes of 4 bits each
void LCDWrite(byte value, boolean rs)
{
   LCDWrite4Bits(value >> 4, rs);
   LCDWrite4Bits(value & 0x0F, rs);
}

// write 4 bits to the display
void LCDWrite4Bits(byte value, boolean rs)
{
  if (rs)
  {
     value |= 0x20; // set RS bit
  }

  PORTC = value;    // write data
  delayMicroseconds(1);    // wait 1 us to settle
  PORTC |= 0x10;           // set E high
  delayMicroseconds(1);    // 1 us delay
  PORTC &= 0x2F;           // set E low
  delayMicroseconds(50);   // wait 50 us
}

// ------------------
// QRSS mode
// ------------------
void QRSSMode(boolean reset)
{
// define the CW (Morse) codes
// the most significant 1 is a marks the beginning of the sequence.
// from the next bit to LSB, 0 means dit (or dot) and 1 means dah
    static byte cwCodes[] =
    {
      B1010101,   // .
      B110010,    // /
      B111111,    // 0
      B101111,    // 1
      B100111,    // 2
      B100011,    // 3
      B100001,    // 4
      B100000,    // 5
      B110000,    // 6
      B111000,    // 7
      B111100,    // 8
      B111110,    // 9
      B1001100,   // ?
      B1011010,   // @
      B101,       // A
      B11000,     // B
      B11010,     // C
      B1100,      // D
      B10,        // E
      B10010,     // F
      B1110,      // G
      B10000,     // H
      B100,       // I
      B10111,     // J
      B1101,      // K
      B10100,     // L
      B111,       // M
      B110,       // N
      B1111,      // O
      B10110,     // P
      B11101,     // Q
      B1010,      // R
      B1000,      // S
      B11,        // T
      B1001,      // U
      B10001,     // V
      B1011,      // W
      B11001,     // X
      B11011,     // Y
      B11100      // Z
    };
 
   // define the state of this code
    const byte RESET = 0;
    const byte START_CHARACTER = 1;
    const byte START_ELEMENT = 2;
    const byte KEY_UP_WAIT = 0x03;
    const byte KEY_UP_END_OF_ELEMENT = 0x03;
    const byte KEY_UP_END_OF_CHARACTER = 0x43;
    const byte KEY_UP_END_OF_STRING = 0x83;
    const byte KEY_DOWN_WAIT = 4;

// put your message here. Usually this is just your callsign.
// You can only use characters in the table above. i.e, upper case letters, numbers, . / ?
    static char message[] = "YOUR MESSAGE";

    // change fSKShift and dotime to something like 500 and 100 if you want to hear normal speed CW for testing
    const byte fSKShift = 6;       // shift up 6 Hz on key down
    const int dotTime = 6000;      // dot time is 6000 ms.
 
    static byte state = RESET;
    static byte bitMask;           // keeps track of where we are in the character
    static byte cwBits;            // this is the cw code from the table above
    static byte dotsToWait;        // used for timing
    static byte charIdx;           // keeps track of where we are in the message
    static int lastMS = 0;         // remember when we last did this
    
    if (reset)
    {
      state = RESET;
      return;
    }
    
    if (_event == BUTTON_PUSH_EVENT)
    {
      switch (_eventParam)
      {
        case 1:
          SetMode(MEMORY_MODE);    // button 1 so move to memory mode
          break;

         case 2:
          state = RESET;          // button 2 sets us back at the beginning of the message
          break;
      }
      _event = 0;
      return;
    }
    
    char toSend;
    int elapsed;                   // how long has passed since we were here last time
    
    switch (state & 0x3F)          // what state are we in? We ignore the 2 most significant bits so the KEY_UP_WAITs go together
    {
      case RESET:
        SetCWKeyState(false, fSKShift);      // key up
        charIdx = 0;               // point to start of message
        state = START_CHARACTER;   // start sending
        break;
      
      case START_CHARACTER:
        toSend = message[charIdx];  // get character to send
        if (toSend == ' ')
        {
          // if it's a space then we wait 4 dot times to give a total of 7 dot times because we have
          // already done 3, i.e, 1 at the end of the last element and 2 at the end of the last character
          dotsToWait = 4;
          lastMS = _ms;
          state = KEY_UP_END_OF_CHARACTER;
        }
        else
        {
          if (toSend < '?')    // get the cw bits to send
          {
             cwBits = cwCodes[toSend - '.'];
          }
          else
          {
            cwBits = cwCodes[toSend - '.' - 5];  // the 5 is because of a gap in our table between ASCII '9' and '?'
          }
          
          bitMask = 0x80;
          while (!(cwBits & bitMask))    // find the most significant 1
          {
            bitMask = bitMask >> 1;
          }
          bitMask = bitMask >> 1;        // move to the first real element
          state = START_ELEMENT;         // start sending
        }
        break;
        
      case START_ELEMENT:
        SetCWKeyState(true, fSKShift);      // key down
        dotsToWait = cwBits & bitMask ? 3 : 1;    // key stays down for 1 dot time for a dit, 3 for a dah
        lastMS = _ms;             // start timing
        state = KEY_DOWN_WAIT;
        break;

      case KEY_UP_WAIT:
      case KEY_DOWN_WAIT:
        elapsed = _ms - lastMS;    // how long since we last did this?
        
        if (elapsed > dotTime)     // have we done a dot time yet?
        {
          lastMS = _ms;            // remember ms for next time
          dotsToWait--;
          
          if (!dotsToWait)        // have we waited all the required dot times?
          {
            if (state == KEY_DOWN_WAIT)
            {
              SetCWKeyState(false, fSKShift);      // key up
              dotsToWait = 1;            // key was down so now wait 1 dot time
              state = KEY_UP_END_OF_ELEMENT;
            }
            else
            {
              switch(state)
              {
                case KEY_UP_END_OF_ELEMENT:  // we just finished the 1 dot wait after a dit or dah
                  if (bitMask > 1)           // have we sent all this character?
                  {
                    bitMask = bitMask >> 1;  // no, so send next element
                    state = START_ELEMENT;
                  }
                  else
                  {
                     dotsToWait = 2;          // we're finished this character so wait 2 more dot times to give a 3 dot character spacing
                     state = KEY_UP_END_OF_CHARACTER;
                  }
                  break;
                  
                case KEY_UP_END_OF_CHARACTER:  // we just finished the 3 (1+2) dot wait after a character
                  charIdx++;                   // point to next character in the message
                  if (message[charIdx])        // is this the end of the message
                  {
                    state = START_CHARACTER;   // not yet so send next charatcer
                  }
                  else
                  {                       // end of message to wait 4 dot time. this gives a total of 7 dot times
                    dotsToWait = 4;       // so we're effectively sending a space before starting the message again
                    state = KEY_UP_END_OF_STRING;  // you might want to make that time a little bigger
                  }
                  break;
                  
                case KEY_UP_END_OF_STRING:  // we just finished the space at the end of the message
                  charIdx = 0;              // reset the pointer and start the message again
                  state = START_CHARACTER;
                  break;
              }
            }
          }
        }
        break;
   }
}

// toggle the 'key' up and down
void SetCWKeyState(boolean isKeyDown, byte fSKShift)
{
  // key down shifts the frequency up
  SetDDSFrequency(_frequency + (isKeyDown ? fSKShift : 0));
  
  LCDSetCursor(15, 0);    // write a * on the display to indicate key down
  LCDWrite(isKeyDown ? '*' : ' ', true);
}
